<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.11.1.0">
<procedure name="main">
<interface/>
<body>
<c>* 模板匹配定位+引脚间距测量及个数统计</c>
<c>* 1、找到图像中具有相同特征区域这个图像(模板区域)</c>
<c>* 2、把该图像作为定位模板，并找到测试区域</c>
<c>* 3、根据模板来匹配待测图像区域并进行定位。</c>
<c>* 4、开始找出待测试区域(图像倾斜幅度变动)</c>
<c>* 5、把待测试区域对应模板的测试区域进行仿射变换，使其与测试区域进行重叠</c>
<c>* 6、开始测量引脚间距及统计对应个数</c>
<c>** 采集图像(使用相机来实时采集，而这里就是使用提供的检测的图片列表)</c>
<l>list_files ('./', 'files', Files)</l>
<c>** 使用正则表达式筛选对应图像</c>
<l>tuple_regexp_select (Files, ['\\.(png|jpg|bmp)'], ImageFiles)</l>
<c>***************** 1、创建图像模板 ******************************</c>
<c>** 读取第一张图像作为创建模板的图像</c>
<l>read_image (Image, ImageFiles[0])</l>
<c>** 获取图像宽和高</c>
<l>get_image_size (Image, Width, Height)</l>
<c>** 获取创建模板的区域</c>
<l>gen_rectangle1 (ROI_0, 185.922, 187.828, 303.797, 410.766)</l>
<c>** 获取矩形的中心坐标</c>
<l>area_center (ROI_0, Area, Row, Column)</l>
<c>** 显示图像的模板区域图像</c>
<l>reduce_domain (Image, ROI_0, ImageReduced)</l>
<c>** 把显示区域作为图像模板进行模板创建</c>
<l>create_shape_model (ImageReduced, 4, rad(0), rad(360), 'auto', 'auto', 'use_polarity', [20,40], 10, ModelID)</l>
<c>** 获取创建模板的轮廓</c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<c>** 设置区域以轮廓方式显示</c>
<l>* dev_set_draw ('margin')</l>
<l>* dev_set_line_width (2)</l>
<c>** 生成区域跟随</c>
<l>gen_rectangle2 (ROI_Check, 160, 302, 0, 160, 7)</l>
<c>** 生成XLD跟随</c>
<l>gen_rectangle2_contour_xld (Rectangle_XLD, 140, 302, 0, 160, 7)</l>
<c>************************** 2、开始进行模板定位测量 *************************</c>
<c>** 获取窗口句柄</c>
<l>dev_get_window (WindowHandle)</l>
<c></c>
<c>** 创建仿射变换矩阵</c>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<c></c>
<l>set_display_font (WindowHandle, 20, 'mono', 'true', 'false')</l>
<l>for Index := 0 to |ImageFiles|-1 by 1</l>
<c>    ** 读取带测量的图像</c>
<l>    read_image (Image, ImageFiles[Index])</l>
<c>    ** 进行模板匹配定位</c>
<l>    find_shape_model (Image, ModelID, rad(0), rad(360), 0.5, 1, 0.5, 'least_squares', 0, 0.9, Row1, Column1, Angle, Score)</l>
<c>    ** 使用仿射变换矩阵进行平移和旋转</c>
<l>    hom_mat2d_translate (HomMat2DIdentity, Row1, Column1, HomMat2DTranslate)</l>
<l>    hom_mat2d_rotate (HomMat2DTranslate, Angle, Row1, Column1, HomMat2DRotate)</l>
<c>    ** 仿射变换模板的轮廓到对应图像位置</c>
<l>    affine_trans_contour_xld (ModelContours, ContoursAffineTrans, HomMat2DRotate)</l>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    ** 进行跟随区域及轮廓仿射变换,刚体变换矩阵(旋转过程中必须固定一个点进行操作)</c>
<l>    vector_angle_to_rigid (Row, Column, 0, Row1, Column1, Angle, HomMat2D)</l>
<c>    ** 仿射变换跟随轮廓()</c>
<l>    affine_trans_contour_xld (Rectangle_XLD, ContoursAffineTrans1, HomMat2D)</l>
<c>    ** 获取轮廓中心点</c>
<l>    area_center_xld (ContoursAffineTrans1, Area1, Row2, Column2, PointOrder)</l>
<c>    ** 生成测量标线</c>
<l>    gen_measure_rectangle2 (Row2, Column2, Angle, 160, 7, Width, Height, 'nearest_neighbor', MeasureHandle)</l>
<c>    ** 生成成对的测量标线</c>
<l>    measure_pairs (Image, MeasureHandle, 1, 30, 'all', 'all', RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)</l>
<c>    *显示</c>
<l>    disp_line (WindowHandle, RowEdgeFirst-8*cos(Angle), ColumnEdgeFirst-8*sin(Angle), RowEdgeFirst+8*cos(Angle), ColumnEdgeFirst+8*sin(Angle))</l>
<l>    disp_line (WindowHandle, RowEdgeSecond-8*cos(Angle), ColumnEdgeSecond-8*sin(Angle), RowEdgeSecond+8*cos(Angle), ColumnEdgeSecond+8*sin(Angle))</l>
<c>    </c>
<c>    *下引角</c>
<c>    *仿射变换跟随2,使用hom_mat2d_translate,hom_mat2d_rotate,affine_trans_pixel</c>
<c>    *先平移矩阵,再旋转矩阵.基于0,0点</c>
<l>    hom_mat2d_translate (HomMat2DIdentity, Row1+104, Column1+6, HomMat2DTranslate1)</l>
<l>    hom_mat2d_rotate (HomMat2DTranslate1, Angle, Row1, Column1, HomMat2DRotate1)</l>
<l>    affine_trans_pixel (HomMat2DRotate1, 0, 0, RowTrans, ColTrans)</l>
<l>    gen_rectangle2_contour_xld (Rectangle1, RowTrans, ColTrans, Angle,162, 7)</l>
<c>    *测量2</c>
<l>    gen_measure_rectangle2 ( RowTrans, ColTrans, Angle, 162, 7, Width, Height, 'nearest_neighbor', MeasureHandle1)</l>
<l>    measure_pairs (Image, MeasureHandle1, 3, 50, 'all', 'all', RowEdgeFirst1, ColumnEdgeFirst1, AmplitudeFirst1, RowEdgeSecond1, ColumnEdgeSecond1, AmplitudeSecond1, IntraDistance1, InterDistance1)</l>
<l>    disp_line (WindowHandle, RowEdgeFirst1-8*cos(Angle), ColumnEdgeFirst1-8*sin(Angle), RowEdgeFirst1+8*cos(Angle), ColumnEdgeFirst1+8*sin(Angle))</l>
<l>    disp_line (WindowHandle, RowEdgeSecond1-8*cos(Angle), ColumnEdgeSecond1-8*sin(Angle), RowEdgeSecond1+8*cos(Angle), ColumnEdgeSecond1+8*sin(Angle))</l>
<l>    distancel:=mean([IntraDistance,IntraDistance1])</l>
<l>    distancelMin:=min([IntraDistance,IntraDistance1])</l>
<l>    dev_disp_text ('引角间隔平均值为:'+distancel$'0.4'+'px', 'window', 12, 12, 'black', [], [])</l>
<l>    dev_disp_text ('引角间隔最小为:'+distancelMin$'0.4'+'px', 'window', 42, 12, 'black', [], [])</l>
<l>    dev_disp_text ('引角总数为'+|[IntraDistance,IntraDistance1]|, 'window', 72, 12, 'black', [], [])</l>
<c>    </c>
<c>    *仿射变换3.区域基原位置变换,相对的平移矩阵,再旋转矩阵.</c>
<l>    hom_mat2d_translate (HomMat2DIdentity, Row1-Row, Column1-Column, HomMat2DTranslate2)</l>
<l>    hom_mat2d_rotate (HomMat2DTranslate2, Angle, Row1, Column1, HomMat2DRotate2)</l>
<l>    affine_trans_region (ROI_Check, ROI_001, HomMat2DRotate2, 'nearest_neighbor')</l>
<c>    *及时释放句柄空间</c>
<l>    close_measure (MeasureHandle)</l>
<l>    close_measure (MeasureHandle1)</l>
<l>    dev_display (ROI_001)</l>
<l>    stop ()</l>
<l>endfor</l>
<l>clear_shape_model (ModelID)</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
