//
// File generated by HDevelop for HALCON/.NET (C#) Version 24.11.1.0
// Non-ASCII strings in this file are encoded in UTF-8.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  // Procedures 
  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
    HTuple hv_Indices = new HTuple();
    HTuple   hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
    HTuple   hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

    // Initialize local and output iconic variables 
    try
    {
      //This procedure sets the text font of the current window with
      //the specified attributes.
      //
      //Input parameters:
      //WindowHandle: The graphics window for which the font will be set
      //Size: The font size. If Size=-1, the default of 16 is used.
      //Bold: If set to 'true', a bold font is used
      //Slant: If set to 'true', a slanted font is used
      //

      HOperatorSet.GetSystem("operating_system", out hv_OS);
      if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
          new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
      {

        hv_Size_COPY_INP_TMP = 16;
      }
      if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
      {
        //Restore previous behavior
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = ((1.13677*hv_Size_COPY_INP_TMP)).TupleInt()
            ;

        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
            ;

        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
      {

        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Courier";
        hv_Fonts[1] = "Courier 10 Pitch";
        hv_Fonts[2] = "Courier New";
        hv_Fonts[3] = "CourierNew";
        hv_Fonts[4] = "Liberation Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {

        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Consolas";
        hv_Fonts[1] = "Menlo";
        hv_Fonts[2] = "Courier";
        hv_Fonts[3] = "Courier 10 Pitch";
        hv_Fonts[4] = "FreeMono";
        hv_Fonts[5] = "Liberation Mono";
        hv_Fonts[6] = "DejaVu Sans Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {

        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Luxi Sans";
        hv_Fonts[1] = "DejaVu Sans";
        hv_Fonts[2] = "FreeSans";
        hv_Fonts[3] = "Arial";
        hv_Fonts[4] = "Liberation Sans";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {

        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Times New Roman";
        hv_Fonts[1] = "Luxi Serif";
        hv_Fonts[2] = "DejaVu Serif";
        hv_Fonts[3] = "FreeSerif";
        hv_Fonts[4] = "Utopia";
        hv_Fonts[5] = "Liberation Serif";
      }
      else
      {

        hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
      }

      hv_Style = "";
      if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Bold";

        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
      {

        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Italic";

        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
      {

        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
      {

        hv_Style = "Normal";
      }

      HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);

      hv_Font_COPY_INP_TMP = "";
      for (hv_Fdx=0; (int)hv_Fdx<=(int)((new HTuple(hv_Fonts.TupleLength()))-1); hv_Fdx = (int)hv_Fdx + 1)
      {

        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_AvailableFonts.TupleFind(
            hv_Fonts.TupleSelect(hv_Fdx));
        }
        if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
          {

            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                hv_Fdx);
            }
            break;
          }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
      {
        throw new HalconException("Wrong value of control parameter Font");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP+"-")+hv_Style)+"-")+hv_Size_COPY_INP_TMP;

      hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
      }
      }
      HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);











      return;
    }
    catch (HalconException HDevExpDefaultException)
    {











      throw HDevExpDefaultException;
    }
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_ROI_0, ho_ImageReduced;
    HObject ho_ModelContours, ho_ROI_Check, ho_Rectangle_XLD;
    HObject ho_ContoursAffineTrans=null, ho_ContoursAffineTrans1=null;
    HObject ho_Rectangle1=null, ho_ROI_001=null;

    // Local control variables 

    HTuple hv_Files = new HTuple(), hv_ImageFiles = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_ModelID = new HTuple(), hv_WindowHandle = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Angle = new HTuple(), hv_Score = new HTuple();
    HTuple hv_HomMat2DTranslate = new HTuple(), hv_HomMat2DRotate = new HTuple();
    HTuple hv_HomMat2D = new HTuple(), hv_Area1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv_PointOrder = new HTuple(), hv_MeasureHandle = new HTuple();
    HTuple hv_RowEdgeFirst = new HTuple(), hv_ColumnEdgeFirst = new HTuple();
    HTuple hv_AmplitudeFirst = new HTuple(), hv_RowEdgeSecond = new HTuple();
    HTuple hv_ColumnEdgeSecond = new HTuple(), hv_AmplitudeSecond = new HTuple();
    HTuple hv_IntraDistance = new HTuple(), hv_InterDistance = new HTuple();
    HTuple hv_HomMat2DTranslate1 = new HTuple(), hv_HomMat2DRotate1 = new HTuple();
    HTuple hv_RowTrans = new HTuple(), hv_ColTrans = new HTuple();
    HTuple hv_MeasureHandle1 = new HTuple(), hv_RowEdgeFirst1 = new HTuple();
    HTuple hv_ColumnEdgeFirst1 = new HTuple(), hv_AmplitudeFirst1 = new HTuple();
    HTuple hv_RowEdgeSecond1 = new HTuple(), hv_ColumnEdgeSecond1 = new HTuple();
    HTuple hv_AmplitudeSecond1 = new HTuple(), hv_IntraDistance1 = new HTuple();
    HTuple hv_InterDistance1 = new HTuple(), hv_distancel = new HTuple();
    HTuple hv_distancelMin = new HTuple(), hv_HomMat2DTranslate2 = new HTuple();
    HTuple hv_HomMat2DRotate2 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ROI_0);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    HOperatorSet.GenEmptyObj(out ho_ROI_Check);
    HOperatorSet.GenEmptyObj(out ho_Rectangle_XLD);
    HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans);
    HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans1);
    HOperatorSet.GenEmptyObj(out ho_Rectangle1);
    HOperatorSet.GenEmptyObj(out ho_ROI_001);
    try
    {
      //模板匹配定位+引脚间距测量及个数统计
      //1、找到图像中具有相同特征区域这个图像(模板区域)
      //2、把该图像作为定位模板，并找到测试区域
      //3、根据模板来匹配待测图像区域并进行定位。
      //4、开始找出待测试区域(图像倾斜幅度变动)
      //5、把待测试区域对应模板的测试区域进行仿射变换，使其与测试区域进行重叠
      //6、开始测量引脚间距及统计对应个数
      //* 采集图像(使用相机来实时采集，而这里就是使用提供的检测的图片列表)

      HOperatorSet.ListFiles("./", "files", out hv_Files);
      //* 使用正则表达式筛选对应图像

      HOperatorSet.TupleRegexpSelect(hv_Files, "\\.(png|jpg|bmp)", out hv_ImageFiles);
      //**************** 1、创建图像模板 ******************************
      //* 读取第一张图像作为创建模板的图像
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {

      HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(0));
      }
      //* 获取图像宽和高

      HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
      //* 获取创建模板的区域

      HOperatorSet.GenRectangle1(out ho_ROI_0, 185.922, 187.828, 303.797, 410.766);
      //* 获取矩形的中心坐标

      HOperatorSet.AreaCenter(ho_ROI_0, out hv_Area, out hv_Row, out hv_Column);
      //* 显示图像的模板区域图像

      HOperatorSet.ReduceDomain(ho_Image, ho_ROI_0, out ho_ImageReduced);
      //* 把显示区域作为图像模板进行模板创建
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {

      HOperatorSet.CreateShapeModel(ho_ImageReduced, 4, (new HTuple(0)).TupleRad()
          , (new HTuple(360)).TupleRad(), "auto", "auto", "use_polarity", (new HTuple(20)).TupleConcat(
          40), 10, out hv_ModelID);
      }
      //* 获取创建模板的轮廓

      HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID, 1);
      //* 设置区域以轮廓方式显示
      if (HDevWindowStack.IsOpen())
      {
        //dev_set_draw ('margin')
      }
      if (HDevWindowStack.IsOpen())
      {
        //dev_set_line_width (2)
      }
      //* 生成区域跟随

      HOperatorSet.GenRectangle2(out ho_ROI_Check, 160, 302, 0, 160, 7);
      //* 生成XLD跟随

      HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle_XLD, 140, 302, 0, 160, 
          7);
      //************************* 2、开始进行模板定位测量 *************************
      //* 获取窗口句柄
      if (HDevWindowStack.IsOpen())
      {
        hv_WindowHandle = HDevWindowStack.GetActive();
      }

      //* 创建仿射变换矩阵

      HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);

      set_display_font(hv_WindowHandle, 20, "mono", "true", "false");
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ImageFiles.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //* 读取带测量的图像
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {

        HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(hv_Index));
        }
        //* 进行模板匹配定位
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {

        HOperatorSet.FindShapeModel(ho_Image, hv_ModelID, (new HTuple(0)).TupleRad()
            , (new HTuple(360)).TupleRad(), 0.5, 1, 0.5, "least_squares", 0, 0.9, 
            out hv_Row1, out hv_Column1, out hv_Angle, out hv_Score);
        }
        //* 使用仿射变换矩阵进行平移和旋转

        HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, hv_Row1, hv_Column1, 
            out hv_HomMat2DTranslate);

        HOperatorSet.HomMat2dRotate(hv_HomMat2DTranslate, hv_Angle, hv_Row1, hv_Column1, 
            out hv_HomMat2DRotate);
        //* 仿射变换模板的轮廓到对应图像位置

        HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffineTrans, 
            hv_HomMat2DRotate);



        //* 进行跟随区域及轮廓仿射变换,刚体变换矩阵(旋转过程中必须固定一个点进行操作)

        HOperatorSet.VectorAngleToRigid(hv_Row, hv_Column, 0, hv_Row1, hv_Column1, 
            hv_Angle, out hv_HomMat2D);
        //* 仿射变换跟随轮廓()

        HOperatorSet.AffineTransContourXld(ho_Rectangle_XLD, out ho_ContoursAffineTrans1, 
            hv_HomMat2D);
        //* 获取轮廓中心点

        HOperatorSet.AreaCenterXld(ho_ContoursAffineTrans1, out hv_Area1, out hv_Row2, 
            out hv_Column2, out hv_PointOrder);
        //* 生成测量标线

        HOperatorSet.GenMeasureRectangle2(hv_Row2, hv_Column2, hv_Angle, 160, 7, 
            hv_Width, hv_Height, "nearest_neighbor", out hv_MeasureHandle);
        //* 生成成对的测量标线

        HOperatorSet.MeasurePairs(ho_Image, hv_MeasureHandle, 1, 30, "all", "all", 
            out hv_RowEdgeFirst, out hv_ColumnEdgeFirst, out hv_AmplitudeFirst, out hv_RowEdgeSecond, 
            out hv_ColumnEdgeSecond, out hv_AmplitudeSecond, out hv_IntraDistance, 
            out hv_InterDistance);
        //显示
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispLine(hv_WindowHandle, hv_RowEdgeFirst-(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeFirst-(8*(hv_Angle.TupleSin())), hv_RowEdgeFirst+(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeFirst+(8*(hv_Angle.TupleSin())));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispLine(hv_WindowHandle, hv_RowEdgeSecond-(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeSecond-(8*(hv_Angle.TupleSin())), hv_RowEdgeSecond+(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeSecond+(8*(hv_Angle.TupleSin())));
        }

        //下引角
        //仿射变换跟随2,使用hom_mat2d_translate,hom_mat2d_rotate,affine_trans_pixel
        //先平移矩阵,再旋转矩阵.基于0,0点
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {

        HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, hv_Row1+104, hv_Column1+6, 
            out hv_HomMat2DTranslate1);
        }

        HOperatorSet.HomMat2dRotate(hv_HomMat2DTranslate1, hv_Angle, hv_Row1, hv_Column1, 
            out hv_HomMat2DRotate1);

        HOperatorSet.AffineTransPixel(hv_HomMat2DRotate1, 0, 0, out hv_RowTrans, 
            out hv_ColTrans);

        HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowTrans, hv_ColTrans, 
            hv_Angle, 162, 7);
        //测量2

        HOperatorSet.GenMeasureRectangle2(hv_RowTrans, hv_ColTrans, hv_Angle, 162, 
            7, hv_Width, hv_Height, "nearest_neighbor", out hv_MeasureHandle1);

        HOperatorSet.MeasurePairs(ho_Image, hv_MeasureHandle1, 3, 50, "all", "all", 
            out hv_RowEdgeFirst1, out hv_ColumnEdgeFirst1, out hv_AmplitudeFirst1, 
            out hv_RowEdgeSecond1, out hv_ColumnEdgeSecond1, out hv_AmplitudeSecond1, 
            out hv_IntraDistance1, out hv_InterDistance1);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispLine(hv_WindowHandle, hv_RowEdgeFirst1-(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeFirst1-(8*(hv_Angle.TupleSin())), hv_RowEdgeFirst1+(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeFirst1+(8*(hv_Angle.TupleSin())));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispLine(hv_WindowHandle, hv_RowEdgeSecond1-(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeSecond1-(8*(hv_Angle.TupleSin())), hv_RowEdgeSecond1+(8*(hv_Angle.TupleCos()
            )), hv_ColumnEdgeSecond1+(8*(hv_Angle.TupleSin())));
        }

        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_distancel = ((hv_IntraDistance.TupleConcat(
            hv_IntraDistance1))).TupleMean();
        }

        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_distancelMin = ((hv_IntraDistance.TupleConcat(
            hv_IntraDistance1))).TupleMin();
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), ("引角间隔平均值为:"+(hv_distancel.TupleString(
              "0.4")))+"px", "window", 12, 12, "black", new HTuple(), new HTuple());
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), ("引角间隔最小为:"+(hv_distancelMin.TupleString(
              "0.4")))+"px", "window", 42, 12, "black", new HTuple(), new HTuple());
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), new HTuple("引角总数为")+(new HTuple(((hv_IntraDistance.TupleConcat(
              hv_IntraDistance1))).TupleLength())), "window", 72, 12, "black", new HTuple(), 
              new HTuple());
          }
        }

        //仿射变换3.区域基原位置变换,相对的平移矩阵,再旋转矩阵.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {

        HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, hv_Row1-hv_Row, hv_Column1-hv_Column, 
            out hv_HomMat2DTranslate2);
        }

        HOperatorSet.HomMat2dRotate(hv_HomMat2DTranslate2, hv_Angle, hv_Row1, hv_Column1, 
            out hv_HomMat2DRotate2);

        HOperatorSet.AffineTransRegion(ho_ROI_Check, out ho_ROI_001, hv_HomMat2DRotate2, 
            "nearest_neighbor");
        //及时释放句柄空间
        HOperatorSet.CloseMeasure(hv_MeasureHandle);
        HOperatorSet.CloseMeasure(hv_MeasureHandle1);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ROI_001, HDevWindowStack.GetActive());
        }
        // stop(...); only in hdevelop
      }
      HOperatorSet.ClearShapeModel(hv_ModelID);

    }
    catch (HalconException HDevExpDefaultException)
    {




























































      throw HDevExpDefaultException;
    }




























































  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

